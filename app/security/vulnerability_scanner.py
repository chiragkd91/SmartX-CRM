"""
Vulnerability Scanner for CRM System
Automated security scanning and monitoring
"""

import os
import json
import subprocess
import logging
from datetime import datetime
from typing import Dict, List, Any, Optional
import requests
import re
from pathlib import Path

class VulnerabilityScanner:
    """Automated security vulnerability scanning system"""
    
    def __init__(self):
        self.logger = logging.getLogger(__name__)
        self.scan_results = {}
        self.vulnerabilities = []
        self.recommendations = []
        self.scan_timestamp = None
    
    def scan_dependencies(self) -> Dict[str, Any]:
        """
        Scan Python package dependencies for vulnerabilities
        Returns scan results with vulnerability details
        """
        self.logger.info("Starting dependency vulnerability scan...")
        
        scan_results = {
            'python_packages': self._scan_python_packages(),
            'frontend_libraries': self._scan_frontend_libraries(),
            'database_vulnerabilities': self._scan_database_vulnerabilities(),
            'timestamp': datetime.now().isoformat()
        }
        
        self.scan_results['dependencies'] = scan_results
        return scan_results
    
    def scan_code_security(self) -> Dict[str, Any]:
        """
        Scan code for security vulnerabilities
        Returns scan results with security issues
        """
        self.logger.info("Starting code security scan...")
        
        scan_results = {
            'sql_injection': self._scan_sql_injection(),
            'xss_vulnerabilities': self._scan_xss_vulnerabilities(),
            'csrf_protection': self._scan_csrf_protection(),
            'authentication_issues': self._scan_authentication_issues(),
            'authorization_issues': self._scan_authorization_issues(),
            'timestamp': datetime.now().isoformat()
        }
        
        self.scan_results['code_security'] = scan_results
        return scan_results
    
    def scan_network_security(self) -> Dict[str, Any]:
        """
        Scan network and infrastructure security
        Returns network security scan results
        """
        self.logger.info("Starting network security scan...")
        
        scan_results = {
            'open_ports': self._scan_open_ports(),
            'ssl_tls_configuration': self._scan_ssl_tls_configuration(),
            'firewall_configuration': self._scan_firewall_configuration(),
            'timestamp': datetime.now().isoformat()
        }
        
        self.scan_results['network_security'] = scan_results
        return scan_results
    
    def perform_full_scan(self) -> Dict[str, Any]:
        """
        Perform comprehensive vulnerability scan
        Returns complete scan results
        """
        self.logger.info("Starting comprehensive vulnerability scan...")
        self.scan_timestamp = datetime.now()
        
        try:
            # Scan dependencies
            dependency_scan = self.scan_dependencies()
            
            # Scan code security
            code_scan = self.scan_code_security()
            
            # Scan network security
            network_scan = self.scan_network_security()
            
            # Compile results
            full_scan_results = {
                'scan_timestamp': self.scan_timestamp.isoformat(),
                'dependency_scan': dependency_scan,
                'code_security_scan': code_scan,
                'network_security_scan': network_scan,
                'total_vulnerabilities': len(self.vulnerabilities),
                'critical_vulnerabilities': len([v for v in self.vulnerabilities if v.get('severity') == 'critical']),
                'high_vulnerabilities': len([v for v in self.vulnerabilities if v.get('severity') == 'high']),
                'medium_vulnerabilities': len([v for v in self.vulnerabilities if v.get('severity') == 'medium']),
                'low_vulnerabilities': len([v for v in self.vulnerabilities if v.get('severity') == 'low']),
                'recommendations': self.recommendations
            }
            
            self.scan_results = full_scan_results
            self.logger.info(f"Vulnerability scan completed. Found {len(self.vulnerabilities)} vulnerabilities.")
            
            return full_scan_results
            
        except Exception as e:
            self.logger.error(f"Vulnerability scan failed: {str(e)}")
            raise
    
    def _scan_python_packages(self) -> Dict[str, Any]:
        """Scan Python packages for known vulnerabilities"""
        python_scan = {
            'vulnerabilities': [],
            'packages_scanned': 0,
            'recommendations': []
        }
        
        try:
            # Check if requirements.txt exists
            requirements_file = Path('requirements.txt')
            if requirements_file.exists():
                with open(requirements_file, 'r') as f:
                    packages = [line.strip().split('==')[0] for line in f if line.strip() and not line.startswith('#')]
                
                python_scan['packages_scanned'] = len(packages)
                
                # Check for known vulnerable packages
                vulnerable_packages = self._check_package_vulnerabilities(packages)
                python_scan['vulnerabilities'].extend(vulnerable_packages)
                
                if vulnerable_packages:
                    python_scan['recommendations'].append("Update vulnerable packages to latest versions")
                else:
                    python_scan['recommendations'].append("All packages are up to date")
            
        except Exception as e:
            python_scan['vulnerabilities'].append({
                'package': 'unknown',
                'severity': 'medium',
                'description': f'Error scanning Python packages: {str(e)}',
                'recommendation': 'Check package scanning configuration'
            })
        
        return python_scan
    
    def _scan_frontend_libraries(self) -> Dict[str, Any]:
        """Scan frontend libraries for vulnerabilities"""
        frontend_scan = {
            'vulnerabilities': [],
            'libraries_scanned': 0,
            'recommendations': []
        }
        
        try:
            # Check for package.json (if using npm)
            package_json = Path('package.json')
            if package_json.exists():
                with open(package_json, 'r') as f:
                    package_data = json.load(f)
                
                dependencies = list(package_data.get('dependencies', {}).keys())
                dev_dependencies = list(package_data.get('devDependencies', {}).keys())
                all_dependencies = dependencies + dev_dependencies
                
                frontend_scan['libraries_scanned'] = len(all_dependencies)
                
                # Check for known vulnerable libraries
                vulnerable_libraries = self._check_library_vulnerabilities(all_dependencies)
                frontend_scan['vulnerabilities'].extend(vulnerable_libraries)
                
                if vulnerable_libraries:
                    frontend_scan['recommendations'].append("Update vulnerable frontend libraries")
                else:
                    frontend_scan['recommendations'].append("All frontend libraries are secure")
            
        except Exception as e:
            frontend_scan['vulnerabilities'].append({
                'library': 'unknown',
                'severity': 'medium',
                'description': f'Error scanning frontend libraries: {str(e)}',
                'recommendation': 'Check frontend library scanning configuration'
            })
        
        return frontend_scan
    
    def _scan_database_vulnerabilities(self) -> Dict[str, Any]:
        """Scan database for security vulnerabilities"""
        db_scan = {
            'vulnerabilities': [],
            'recommendations': []
        }
        
        try:
            # Check database configuration
            config_file = Path('config.py')
            if config_file.exists():
                with open(config_file, 'r') as f:
                    config_content = f.read()
                
                # Check for hardcoded credentials
                if re.search(r'password\s*=\s*["\'][^"\']+["\']', config_content):
                    db_scan['vulnerabilities'].append({
                        'type': 'hardcoded_credentials',
                        'severity': 'high',
                        'description': 'Hardcoded database credentials found in configuration',
                        'recommendation': 'Use environment variables for sensitive data'
                    })
                
                # Check for SQLite in production
                if 'sqlite:///' in config_content:
                    db_scan['vulnerabilities'].append({
                        'type': 'sqlite_production',
                        'severity': 'medium',
                        'description': 'SQLite database detected - not recommended for production',
                        'recommendation': 'Use PostgreSQL or MySQL for production environments'
                    })
            
        except Exception as e:
            db_scan['vulnerabilities'].append({
                'type': 'scan_error',
                'severity': 'medium',
                'description': f'Error scanning database configuration: {str(e)}',
                'recommendation': 'Check database configuration manually'
            })
        
        return db_scan
    
    def _scan_sql_injection(self) -> Dict[str, Any]:
        """Scan for SQL injection vulnerabilities"""
        sql_scan = {
            'vulnerabilities': [],
            'files_scanned': 0,
            'recommendations': []
        }
        
        try:
            # Scan Python files for SQL injection patterns
            python_files = list(Path('app').rglob('*.py'))
            sql_scan['files_scanned'] = len(python_files)
            
            sql_patterns = [
                r'execute\s*\(\s*["\'][^"\']*\+[^"\']*["\']',
                r'execute\s*\(\s*f["\'][^"\']*\{[^}]*\}',
                r'execute\s*\(\s*["\'][^"\']*%[^"\']*["\']',
                r'raw\s*\(\s*["\'][^"\']*\+[^"\']*["\']'
            ]
            
            for file_path in python_files:
                with open(file_path, 'r', encoding='utf-8') as f:
                    content = f.read()
                    lines = content.split('\n')
                    
                    for line_num, line in enumerate(lines, 1):
                        for pattern in sql_patterns:
                            if re.search(pattern, line):
                                sql_scan['vulnerabilities'].append({
                                    'file': str(file_path),
                                    'line': line_num,
                                    'severity': 'high',
                                    'description': 'Potential SQL injection vulnerability',
                                    'code': line.strip(),
                                    'recommendation': 'Use parameterized queries or ORM'
                                })
            
            if sql_scan['vulnerabilities']:
                sql_scan['recommendations'].append("Fix SQL injection vulnerabilities using parameterized queries")
            else:
                sql_scan['recommendations'].append("No SQL injection vulnerabilities detected")
            
        except Exception as e:
            sql_scan['vulnerabilities'].append({
                'file': 'unknown',
                'line': 0,
                'severity': 'medium',
                'description': f'Error scanning for SQL injection: {str(e)}',
                'recommendation': 'Check SQL injection scanning configuration'
            })
        
        return sql_scan
    
    def _scan_xss_vulnerabilities(self) -> Dict[str, Any]:
        """Scan for XSS vulnerabilities"""
        xss_scan = {
            'vulnerabilities': [],
            'files_scanned': 0,
            'recommendations': []
        }
        
        try:
            # Scan template files for XSS patterns
            template_files = list(Path('app/templates').rglob('*.html'))
            xss_scan['files_scanned'] = len(template_files)
            
            xss_patterns = [
                r'\{\{[^}]*\}\}',  # Jinja2 template variables
                r'<script[^>]*>',  # Script tags
                r'on\w+\s*=',      # Event handlers
                r'javascript:',    # JavaScript protocol
            ]
            
            for file_path in template_files:
                with open(file_path, 'r', encoding='utf-8') as f:
                    content = f.read()
                    lines = content.split('\n')
                    
                    for line_num, line in enumerate(lines, 1):
                        for pattern in xss_patterns:
                            if re.search(pattern, line, re.IGNORECASE):
                                xss_scan['vulnerabilities'].append({
                                    'file': str(file_path),
                                    'line': line_num,
                                    'severity': 'high',
                                    'description': 'Potential XSS vulnerability',
                                    'code': line.strip(),
                                    'recommendation': 'Use proper escaping and input validation'
                                })
            
            if xss_scan['vulnerabilities']:
                xss_scan['recommendations'].append("Fix XSS vulnerabilities using proper escaping")
            else:
                xss_scan['recommendations'].append("No XSS vulnerabilities detected")
            
        except Exception as e:
            xss_scan['vulnerabilities'].append({
                'file': 'unknown',
                'line': 0,
                'severity': 'medium',
                'description': f'Error scanning for XSS: {str(e)}',
                'recommendation': 'Check XSS scanning configuration'
            })
        
        return xss_scan
    
    def _scan_csrf_protection(self) -> Dict[str, Any]:
        """Scan for CSRF protection"""
        csrf_scan = {
            'vulnerabilities': [],
            'files_scanned': 0,
            'recommendations': []
        }
        
        try:
            # Check for CSRF protection in forms
            template_files = list(Path('app/templates').rglob('*.html'))
            csrf_scan['files_scanned'] = len(template_files)
            
            csrf_token_patterns = [
                r'csrf_token',
                r'_token',
                r'csrfmiddlewaretoken'
            ]
            
            forms_without_csrf = []
            
            for file_path in template_files:
                with open(file_path, 'r', encoding='utf-8') as f:
                    content = f.read()
                    
                    # Check for forms
                    if '<form' in content.lower():
                        has_csrf = any(re.search(pattern, content, re.IGNORECASE) for pattern in csrf_token_patterns)
                        
                        if not has_csrf:
                            forms_without_csrf.append(str(file_path))
            
            if forms_without_csrf:
                csrf_scan['vulnerabilities'].append({
                    'type': 'missing_csrf',
                    'severity': 'high',
                    'description': f'Forms without CSRF protection found in {len(forms_without_csrf)} files',
                    'files': forms_without_csrf,
                    'recommendation': 'Add CSRF tokens to all forms'
                })
                csrf_scan['recommendations'].append("Implement CSRF protection for all forms")
            else:
                csrf_scan['recommendations'].append("CSRF protection appears to be implemented")
            
        except Exception as e:
            csrf_scan['vulnerabilities'].append({
                'type': 'scan_error',
                'severity': 'medium',
                'description': f'Error scanning for CSRF protection: {str(e)}',
                'recommendation': 'Check CSRF protection manually'
            })
        
        return csrf_scan
    
    def _scan_authentication_issues(self) -> Dict[str, Any]:
        """Scan for authentication security issues"""
        auth_scan = {
            'vulnerabilities': [],
            'recommendations': []
        }
        
        try:
            # Check for weak password policies
            auth_files = list(Path('app').rglob('*auth*.py')) + list(Path('app').rglob('*login*.py'))
            
            for file_path in auth_files:
                with open(file_path, 'r', encoding='utf-8') as f:
                    content = f.read()
                    
                    # Check for password length validation
                    if 'password' in content.lower() and not re.search(r'len\s*\(\s*password\s*\)\s*>=\s*\d+', content):
                        auth_scan['vulnerabilities'].append({
                            'file': str(file_path),
                            'type': 'weak_password_policy',
                            'severity': 'medium',
                            'description': 'No password length validation detected',
                            'recommendation': 'Implement minimum password length requirements'
                        })
                    
                    # Check for password complexity
                    if 'password' in content.lower() and not re.search(r'[A-Z].*[a-z].*[0-9]', content):
                        auth_scan['vulnerabilities'].append({
                            'file': str(file_path),
                            'type': 'weak_password_complexity',
                            'severity': 'medium',
                            'description': 'No password complexity requirements detected',
                            'recommendation': 'Implement password complexity requirements'
                        })
            
            if not auth_scan['vulnerabilities']:
                auth_scan['recommendations'].append("Authentication security appears adequate")
            else:
                auth_scan['recommendations'].append("Implement stronger authentication policies")
            
        except Exception as e:
            auth_scan['vulnerabilities'].append({
                'type': 'scan_error',
                'severity': 'medium',
                'description': f'Error scanning authentication: {str(e)}',
                'recommendation': 'Check authentication security manually'
            })
        
        return auth_scan
    
    def _scan_authorization_issues(self) -> Dict[str, Any]:
        """Scan for authorization security issues"""
        authz_scan = {
            'vulnerabilities': [],
            'recommendations': []
        }
        
        try:
            # Check for missing authorization checks
            route_files = list(Path('app/routes').rglob('*.py'))
            
            for file_path in route_files:
                with open(file_path, 'r', encoding='utf-8') as f:
                    content = f.read()
                    
                    # Check for route decorators without authorization
                    routes = re.findall(r'@.*route\s*\([^)]*\)', content)
                    auth_decorators = re.findall(r'@.*login_required|@.*auth_required|@.*permission_required', content)
                    
                    if routes and not auth_decorators:
                        authz_scan['vulnerabilities'].append({
                            'file': str(file_path),
                            'type': 'missing_authorization',
                            'severity': 'high',
                            'description': 'Routes without authorization checks detected',
                            'recommendation': 'Add authorization decorators to all routes'
                        })
            
            if not authz_scan['vulnerabilities']:
                authz_scan['recommendations'].append("Authorization checks appear to be implemented")
            else:
                authz_scan['recommendations'].append("Implement authorization checks for all routes")
            
        except Exception as e:
            authz_scan['vulnerabilities'].append({
                'type': 'scan_error',
                'severity': 'medium',
                'description': f'Error scanning authorization: {str(e)}',
                'recommendation': 'Check authorization manually'
            })
        
        return authz_scan
    
    def _scan_open_ports(self) -> Dict[str, Any]:
        """Scan for open ports"""
        port_scan = {
            'open_ports': [],
            'recommendations': []
        }
        
        try:
            # Common ports to check
            common_ports = [21, 22, 23, 25, 53, 80, 443, 3306, 5432, 8080]
            
            for port in common_ports:
                try:
                    # This is a simplified check - in production, use proper port scanning tools
                    if port in [80, 443, 8080]:  # Assume these are open for web services
                        port_scan['open_ports'].append({
                            'port': port,
                            'service': self._get_service_name(port),
                            'status': 'open',
                            'recommendation': 'Ensure proper firewall rules'
                        })
                except:
                    pass
            
            port_scan['recommendations'].append("Configure firewall to allow only necessary ports")
            
        except Exception as e:
            port_scan['recommendations'].append(f"Error scanning ports: {str(e)}")
        
        return port_scan
    
    def _scan_ssl_tls_configuration(self) -> Dict[str, Any]:
        """Scan SSL/TLS configuration"""
        ssl_scan = {
            'vulnerabilities': [],
            'recommendations': []
        }
        
        try:
            # Check if HTTPS is configured
            config_file = Path('config.py')
            if config_file.exists():
                with open(config_file, 'r') as f:
                    content = f.read()
                
                if 'https' not in content.lower() and 'ssl' not in content.lower():
                    ssl_scan['vulnerabilities'].append({
                        'type': 'no_ssl_config',
                        'severity': 'high',
                        'description': 'No SSL/TLS configuration detected',
                        'recommendation': 'Configure HTTPS for production'
                    })
            
            ssl_scan['recommendations'].append("Use HTTPS in production environments")
            
        except Exception as e:
            ssl_scan['vulnerabilities'].append({
                'type': 'scan_error',
                'severity': 'medium',
                'description': f'Error scanning SSL configuration: {str(e)}',
                'recommendation': 'Check SSL configuration manually'
            })
        
        return ssl_scan
    
    def _scan_firewall_configuration(self) -> Dict[str, Any]:
        """Scan firewall configuration"""
        firewall_scan = {
            'vulnerabilities': [],
            'recommendations': []
        }
        
        try:
            # Check for firewall configuration files
            firewall_files = ['iptables', 'ufw', 'firewalld']
            
            firewall_scan['recommendations'].append("Configure firewall rules for production")
            firewall_scan['recommendations'].append("Allow only necessary ports and services")
            
        except Exception as e:
            firewall_scan['vulnerabilities'].append({
                'type': 'scan_error',
                'severity': 'medium',
                'description': f'Error scanning firewall: {str(e)}',
                'recommendation': 'Check firewall configuration manually'
            })
        
        return firewall_scan
    
    # Helper methods
    def _check_package_vulnerabilities(self, packages: List[str]) -> List[Dict[str, Any]]:
        """Check for known vulnerabilities in Python packages"""
        vulnerabilities = []
        
        # This would typically use a vulnerability database API
        # For now, return empty list as placeholder
        return vulnerabilities
    
    def _check_library_vulnerabilities(self, libraries: List[str]) -> List[Dict[str, Any]]:
        """Check for known vulnerabilities in frontend libraries"""
        vulnerabilities = []
        
        # This would typically use npm audit or similar
        # For now, return empty list as placeholder
        return vulnerabilities
    
    def _get_service_name(self, port: int) -> str:
        """Get service name for port number"""
        service_map = {
            21: 'FTP',
            22: 'SSH',
            23: 'Telnet',
            25: 'SMTP',
            53: 'DNS',
            80: 'HTTP',
            443: 'HTTPS',
            3306: 'MySQL',
            5432: 'PostgreSQL',
            8080: 'HTTP-Alt'
        }
        return service_map.get(port, 'Unknown')
    
    def generate_vulnerability_report(self) -> str:
        """Generate human-readable vulnerability report"""
        if not self.scan_results:
            return "No scan results available. Run perform_full_scan() first."
        
        report = f"""
# Vulnerability Scan Report
Generated: {self.scan_results.get('scan_timestamp', 'Unknown')}

## Summary
- Total Vulnerabilities: {self.scan_results.get('total_vulnerabilities', 0)}
- Critical: {self.scan_results.get('critical_vulnerabilities', 0)}
- High: {self.scan_results.get('high_vulnerabilities', 0)}
- Medium: {self.scan_results.get('medium_vulnerabilities', 0)}
- Low: {self.scan_results.get('low_vulnerabilities', 0)}

## Recommendations
"""
        
        for rec in self.scan_results.get('recommendations', []):
            report += f"- {rec}\n"
        
        return report 